### 1. Understand what is a program ?

- Chương trình máy tính là tổng hợp các thao tác được sắp xếp cụ thể để máy tính thực thi, các chương trình máy tính yêu cầu các chương trình để hoạt động đúng.
- Chương trình này chứa một chuỗi các hướng dẫn từng lần một mà máy tính tuân theo. Thông thường, chương trình được đưa vào một vùng lưu trữ mà máy tính có thể truy cập được. Máy tính nhận một lệnh và thực hiện nó và sau đó nhận lệnh tiếp theo. Vùng lưu trữ hoặc bộ nhớ cũng có thể chứa dữ liệu mà lệnh hoạt động
- Một chương trình máy tính được viết bằng các ngôn ngữ lập trình như Java, Javascript, ... Các câu lệnh sẽ tuân theo cú pháp cũng như syntax của các ngôn ngữ này. Tuy nhiên để máy tính có thể hiểu được thì chúng phải được biên dịch thông qua ngôn ngữ máy (Các bit nhị phân 0 1 0 1)

### 2. Understand what is a programming language ?

- Ngôn ngữ lập trình là ngôn ngữ hình thức bao gồm một tập hợp các lệnh tạo ra nhiều loại đầu ra khác nhau. Ngôn ngữ lập trình được sử dụng trong lập trình máy tính để thực hiện các thuật toán.

### 3. Is JavaScript a Programming Language

- Jvascript là một ngôn ngữ lập trình cốt lõi của Worl Wide Web
- Là ngôn ngữ lập trình cấp cao, được biên dịch Just In Time (JIT - gọi là biên dịch động hoặc biên dịch thời gian chạy - là một cách thực thi mã máy tính liên quan đến việc biên dịch trong quá trình thực thi chương trình (tại thời điểm chạy ) chứ không phải trước khi thực thi.) theo tiêu chuẩn của ECMAScript

### 4. Understand the main problem of programming ?

- Lập trình để thực hiện một cách chính xác những tao tác được lên kịch bản sẵn từ các ngôn ngữ lập trình, nó giúp làm việc hiệu quả - chính xác gần như tuyệt đối

### 5. Understand what is the art of programming ?

- Em nghĩ nghệ thuật lập trình là việc tạo ra các mã - chúng không chỉ đơn thuần là chạy được, mà còn chạy một cách "tối ưu" qua những thuật toán, clean code, ...

### 6. Understand what is best practices ?

YES

### 7. Understand what is the lowest level program look like ?

- Trông gần giống mã máy (Các bit nhị phân 0 1 0 1 hoặc mã Hexa)

### 8. Understand what is a good programming language ?

- Một ngôn ngữ lập trình tốt khi cú pháp thân thiện với người dùng, thời gian thực thi nhanh, ...

### 9. Understand the history behind JavaScript ?

- JavaScript được Brendan Eich phát minh vào năm 1995 sau khi ông này nhận thấy sự bất tiện của các trang web chỉ được thiết kế tĩnh qua HTML CSS
- Phiên bản đầu tiên của ngôn ngữ này được đặt tên là Mocha vào tháng 5 năm 1995, đổi tên thành LiveScript vào tháng 9 năm 1995, và được đổi tên thành JavaScript vào tháng 12 năm 1995.

### 10. Is JavaScript and Java related ?

- Java và Javascript không liên quan đến nhau

* Java là ngôn ngữ hướng đối tượng, có thể sử dụng để tạo ra các chương trình chạy trên mọi nền tảng
* JS là ngôn ngữ lập trình làm cho các trang web có thể tương tác, còn gọi là ngôn ngữ trình duyệt

### 11. What is ECMAScript Standard ?

- ECMAScript là một tiêu chuẩn cho một ngôn ngữ kịch bản. Nó chỉ định các tính năng cốt lõi mà một ngôn ngữ kịch bản nên cung cấp và cách triển khai các tính năng đó.

### 12. Able to name some versions of ECMAScript

- ES1 1997
- ES2 1998
- ES3 1999
- ES4 Abandoned
- ES5 2009
- ES6 2015
- ES7 2016
- ES8 2017
- ES9 2018

### 13. Able to name some platforms on which JavaScript is used ?

- React, Angular, VueJS, Jquery, NodeJs và nhiều thư viện khác

### 14. Understand what is Code ?

- Code được hiểu là những ngôn ngữ lập trình cơ bản. Lập trình viên sẽ sử dụng những ngôn ngữ lập trình này để đưa vào máy tính. Từ đó, máy có thể đọc, nhận diện được những đoạn code này để ghi nhớ thông tin

### 15. Able to run JavaScript Code in Browsers ?

- JS có thể chạy trên trình duyệt

### 16. Able to run JavaScript Code in NodeJS ?

Yes

### 17. Understand what is stored inside a computer ?

- Máy tính lưu trữ dữ liệu dưới dạng dãy bit, mỗi bit là một kí hiệu là 0 hoặc 1 (còn gọi là các bit nhị phân, bit là đơn vị nhỏ nhất để lưu trữ thông tin)
- Thông tin trong máy tính được tổ chức dưới dạng các tệp (tệp văn bản, tệp hình ảnh, tệp video, …). Các tệp được lưu trữ trong các thiết bị nhớ như thẻ nhớ, đĩa cứng,…

### 18. Understand what is the representation of 10 in computer world ?

- hệ cơ số 10 (từ 0 - 9) là hệ thống tiêu chuẩn để biểu thị số nguyên và số không nguyên (số thập phân)

### 19. Understand what is the representation of 2018 in computer world ?

- Năm 2018, đại diện của máy tính chính là trí truệ nhân tạo đặc biệt trong y học
- Hệ thống AlphaGo Zero của Google giờ có thể đủ khả năng giải quyết những vấn đề phức tạp nhất của y học, như hiện tượng nếp gấp protein (protein folding) - thứ gây ra Alzheimer và Parkinson. Hay như Microsoft, họ đảm bảo rằng năm 2018 sẽ giải mã thành công bộ mã di truyền gây ung thư, dựa vào hệ thống AI trong phòng thí nghiệm của Cambridge.

### 20. Understand what is a value in JavaScript ?

- Giá trị JavaScript là các giá trị bao gồm các giá trị như Booleans, Strings, mảng, số, v.v.

### 21. Understand what is out of memory ?

- Thường là trạng thái hoạt động không mong muốn của máy tính khi không có bộ nhớ bổ sung nào có thể được cấp phát để sử dụng bởi các chương trình hoặc hệ điều hành. Hệ thống như vậy sẽ không thể tải bất kỳ chương trình bổ sung nào và vì nhiều chương trình có thể tải thêm dữ liệu vào bộ nhớ trong quá trình thực thi, các chương trình này sẽ ngừng hoạt động chính xác

### 22. Understand how a number is represented in computer's memory

- Các con số trong máy tính được biểu diễn bằng số nhị phân

### 23. Understand how a number is represented in computer's memory

- Trong JavaScript, số thông thường được biểu diễn dưới dạng số thực dấu phẩy động theo chuẩn IEEE-754. Định dạng này sử dụng 64 bit để lưu trữ một số, trong đó:
  - 52 bit dùng để lưu trữ các chữ số phần nguyên.
  - 11 bit để lưu trữ phần thập phân.
  - 1 bit để lưu trữ dấu (0 - số dương và 1 - số âm).
- IEEE-754 là tiêu chuẩn xác định:
  - định dạng số học: tập hợp dữ liệu dấu phẩy động nhị phân và thập phân , bao gồm các số hữu hạn (bao gồm các số không có dấu và số phụ ), số vô hạn và giá trị đặc biệt "không phải là số" ( NaN )
  - các định dạng trao đổi: mã hóa (chuỗi bit) có thể được sử dụng để trao đổi dữ liệu dấu phẩy động ở dạng hiệu quả và nhỏ gọn
  - quy tắc làm tròn: các thuộc tính cần thỏa mãn khi làm tròn số trong quá trình số học và chuyển đổi
  - phép toán : số học và các phép toán khác (chẳng hạn như hàm lượng giác ) trên các định dạng số học
  - xử lý ngoại lệ: chỉ báo về các điều kiện ngoại lệ (chẳng hạn như chia cho 0 , tràn, v.v.

### 24. Understand how many different numbers you can represent ?

- Nếu có n bit, thì bạn có thể biểu diễn 2 ^ n số với chúng
- ví dụ; nếu n = 2 => thì số các số bạn có thể biểu diễn là 2 ^ 2 = 4 và các số là 00, 01, 10, 11

### 25. Understand why JavaScript choose 64-bit chunks instead of 8 or 16 bits ?

- JavaScript chọn khối 64bits thay vì 8 hoặc 16 bits là bởi vì trong javascript không khai báo kiểu dữ liệu như int, float, long, ... như các ngôn ngữ khác vì thế nó cần 64bits để có thể lưu trữ tất cả các giá trị;

### 26. why in practice does JavaScript use less than 18 trillion to store numbers?

- Em nghĩ là để lưu trữ và xử lí một con số lớn như vậy thì cần rất nhiều bộ nhớ cũng như thời gian, việc một ứng dụng đợi quá lâu để xử lý là không cần thiết. Trong trường hợp sử dụng các con số lớn như vậy, người ta thường chọn các ngôn ngữ như python.

### 27. Understand how to create/store a fractional number ?

- Máy tính lưu một phân số dưới dạng dấu phẩy động

### 28. Understand what is NaN ?

- Not a Number là một kiểu dữ liệu thuộc dạng Number.
- Các cách để phát sinh NaN
  - Lấy số 0 chia cho số 0
  - Lấy vô cùng (infinity) chia cho vô cùng (infinity)
  - Nhân vô cùng (infinity) với số 0
  - Bất kỳ phép tính toán nào trong đó NaN là một toán hạng
  - Chuyển đổi một xâu non-numeric hoặc undefined về dạng number
- Mọi phép so sánh với NaN đều trả về giá trị là false, để so sánh một giá trị có phải NaN hay không ta sử dụng `isNaN()`

### 29. Understand what is Unicode standard ?

- Tiêu chuẩn Unicode là một hệ thống mã hóa ký tự được thiết kế để hỗ trợ việc trao đổi, xử lý và hiển thị trên toàn thế giới các văn bản viết bằng các ngôn ngữ và kỹ thuật đa dạng của thế giới hiện đại. Ngoài ra, nó hỗ trợ các văn bản cổ điển và lịch sử của nhiều ngôn ngữ viết.

- Về mặt hình thức, một phiên bản của Tiêu chuẩn Unicode được xác định bởi một phiên bản của đặc điểm kỹ thuật cốt lõi, Tiêu chuẩn Unicode , cùng với Biểu đồ mã , Phụ lục chuẩn Unicode và Cơ sở dữ liệu ký tự Unicode . Bản phân tích chi tiết về nội dung của từng phiên bản được cung cấp trên Kho lưu trữ các phiên bản Unicode . Xem thêm bản tóm tắt thông tin phiên bản trong Giới thiệu về phiên bản .

### 30. Can string be divided, multiplied, or subtracted ?

Yes
VD:

```js
"50" - 5 => 45
"50" + 5 => 505
"50" : 5 => 10
10 + "5" => 105
10 - "5" => 5
```

### 31. Is typeof unary or binary operator ?

- unary operator

### 32. Is + a unary or binary operator ? Is + a unary or binary operator ?

- unary operator

### 33. Recall how many type of operator you have encountered so far ?

+, -, \*, /, \*\*, %, &&, ||, ??, !, toán tử 3 ngôi, ...

### 34. How many kind of comparision ? List them all

==, ===, !=, >, <, >=, <=

### 35. What is the special value in JavaScript that is not equal to itselft ?

NaN

### 36. How many logical operators in JavaScript ?

- Có 4 toán tử trong javascript: ||, &&, ??, !

### 37. Why we use logical operators ?

- Bởi vì có giá trị không thể biết là sai hay đúng mà ta cần xử lý điều gì đó theo điều kiện, mặt khác nó giúp code ngắn gọn hơn, không phải sử dụng câu điều kiện if else

### 38. What is the problem when we mix logical operator with arithmetic operator ? How to fix ?

5 - 5 && 10 => 0 , fix bằng cách thêm dấu ngoặc (): 5 - (5 && 10)

### 39. Understand what is type coercion ?

```js
const value1 = "5";
const value2 = 9;
let sum = value1 + value2;

console.log(sum); // 59
```

### 40. Understand what happened when you use arithmetic operator with non-number type ?

- Kêt quả sẽ là một chuỗi gộp 2 số hạng lại

# Checklist 2

### 1. Understand what is expressions ? Provide an example of expressions ?

- Bất kì mã nào được đánh giá là một giá trị đều được coi là biểu thức
- VD: 10 được đánh giá là một số trong js được coi là một biểu thức

### 2. Understand what is statement ? Provide an example of statement ?

- Các câu lệnh được sử dụng trong JavaScript để kiểm soát luồng chương trình của nó
- VD: break, continue, for-in, for-of, ...

### 3. Provide an example using do-while ?

```js
let i = 0;
do {
  console.log("Counting");
  i++;
} while (i < 10);
```

### 4. Bài tập Reversing an array

```js
let arrayValue = [1, 2, 3, 4, 5];

function reversingArray(arr) {
  if(arr.length <== 0) return;
  const tmpArr = [...arr];
  for (let i = 0; i < tmpArr.length; i++) {
    arr[i] = tmpArr[tmpArr.length - 1 - i];
  }
  return arr;
}

reversingArray(arrayValue);
console.log(arrayValue); // [5, 4, 3, 2, 1]
```

# Phần thắc mắc

### 5. Side Effect

- Side Effects nghĩa là đang nói tới một chương trình phần mềm, khi có một tác động xảy ra, nó dẫn tới việc dữ liệu của chương trình bị thay đổi.

VD:

- Một hàm submitLogin. Sau khi user nhập username và pass xong nhấn submit thì sẽ trigger hàm submitLogin.
  - Trong hàm submitLogin này sẽ làm những việc này:
    - Submit thông tin lên server và nhận thông tin trả về (1)
    - Nếu trạng thái thành công redirect sang Dashboard (2)
    - Nếu trạng thái thất bại sẽ hiển thị lỗi (3)

=> Ở đây theo như tên gọi submitLogin thì công việc chính của nó là (1). (2) và (3) là side effect vì nó không phải là nhiệm vụ chính của hàm và phải dựa vào kết quả từ (1)

# Javascript Advandce

### 1. Understand that JavaScript is a compiled language ?

- Ngôn ngữ JavaScript thực sự được biên dịch, nó gần với được Biên dịch hơn là thông dịch. Nó được biên dịch mọi lúc Bởi vì Sau khi compilation quá trình tạo ra một mã byte nhị phân, quá trình JS virtual machinesẽ thực thi nó.
- Giải thích thêm câu trả lời này ở phần trả lời của câu hỏi bên dưới.

### 2. Understand how JavaScript compile code ? (3 steps)

- Step 1: Tokenizing (Mã hóa)
  - Đây là giai đoạn đầu tiên. Ở giai đoạn này nó sẽ quét qua source code và chia nhỏ source code thành các mã có ý nghĩa được gọi là tokens
    - VD: `var myNumber = 7;` có thể được mã hóa thành `var, myNumber, =, 7, ;`
- Step 2: Parsing (Phân tích cú pháp)
  - Đây là giai đoạn thứ hai của quá trình. Ở giai đoạn này nó sẽ lấy mảng tokens làm đầu vào và biến nó trở thành một cây gồm các phần tử lồng nhau. Cây này được gọi là `Abstract Syntax Tree(AST).`
- Step 3: Code-Generation.

  - Trong giai đoạn này, `AST` sử dụng làm đầu vào và mã byte thực thi tạo ra bởi môi trường - nơi code sẽ chạy. Sau đó, mã byte thực thi được tinh chỉnh / chuyển đổi thêm nữa bằng trình biên dịch JIT (Just-In-Time) tối ưu hóa.

=> Dưới đây là hình minh họa cách mã JS biên dịch

![image info](./imgs/js%20complied.avif)

### 3. Understand how many cast of character in JavaScript ?

- EM chưa hiểu câu hỏi lắm

### 4. Understand 2 distinct actions are taken for a variable assigment (var a = 2) ?

- Thực chất câu lệnh trên đang thực hiện hai hành động
  - Hành động thứ nhất là khai báo biến: `var a;`
  - Hành động thứ hai là gán giá trị cho biến `a = 2`

### 5. Understand LHS and RHS ?

- Tham chiếu LHS (Left-hand side - phía bên trái) là tham chiếu trong đó trình biên dịch cố gắng truy cập vùng chứa , hoặc cụ thể hơn, địa chỉ được đại diện bởi biến.
- Tham chiếu RHS (Right-hand side - phía bên phải) là tham chiếu mà trình biên dịch cố gắng tìm giá trị được giữ bởi biến.
- Ví dụ minh họa
  - VD1: Với đoạn code `console.log( a );` Tham chiếu tới a là tham chiếu RHS bởi vì ta không gán gì cho a cả. Engine đơn giản là tìm kiếm để lấy ra giá trị của a ,và sau đó truyền vào như là tham số cho console.log(..) </br>
    Ngược lại: a = 2; Tham chiếu tới a ở đây là LHS, bởi vì ở đây ta không thực sự quan tâm giá trị hiện tại là gì, chỉ đơn giản là muốn tìm kiếm biến và gán giá trị = 2.
  - VD2:

```js
function foo(a) {
  console.log(a); // 2
}

foo(2);
```

- Ở đây dòng cuối cùng gọi foo (..) thực chất là một yêu cầu tham chiếu RHS đến foo, có nghĩa là, "hãy tìm giá trị của foo, và đưa nó cho tôi." Cặp ngoặc này (..) có nghĩa là sau khi tìm thấy thì thực thi nó như 1 function. Tiếp theo tương tự như giải thích bên trên, đoạn console.log(a) cũng chứa 1 tham chiếu RHS tới a. Tuy nhiên, ở đây có tới 2 tham chiếu LHS đã bị ta bỏ qua, do nó không phải là phép gán biến explicit. Thực chất, khi truyên tham số vào cho foo (tương tự với truyền tham só vào cho console.log) đã thực hiện phép gán a = 2 nên đây cũng là 1 tham chiếu LHS

### 6. Understand how Engine/Score Manager converse ?

```js
function foo(a) {
  console.log(a); // 2
}

foo(2);
```

- Đoạn code trên được thực thi, bản chất là có một cuộc đối thoại diễn ra như sau: (NGUỒN: THAM KHẢO TẠI VIBLO)

```js
Engine: Hey Scope, tôi muốn tham chiếu RHS tới foo. Mài có biết nó ko ?

Scope: Sao không, tau biết. Compiler đã định nghĩa nó vừa xong. Nó là 1 function. À đây rồi.

Engine: Tuyệt, cảm ơn! OK, tôi đang thực thi foo luôn đây.

Engine: Này, Scope, tau muốn tham chiếu LHS tới a, biết nó chứ ?

Scope: Có. Compiler khai báo nó là một tham số cho foo. Đây rồi.

Engine: Vẫn được việc như mọi khi. Cảm ơn nhiều nhé. Bây giờ, thời gian để tau gán 2 cho a.

Engine: Hey, Scope, xin lỗi lại phiền mài lần nữa. Tôi cần một tìm kiếm RHS look-up đến console. Bao giờ nghe nói về nó chưa?

Scope: Không vấn đề gì, Engine, đây là công việc mà. Có, tôi biết console. Anh ấy là giao diện được tích hợp sẵn. Đây rồi.

Engine: Nuột. Để tau tìm log(..). OK, đây rồi, nó là một function.

Engine: Yo, Phạm vi. Mài có thể giúp tau tham chiếu RHS đến a được không. Tau khi là tau không quên nó mà chỉ muốn kiểm tra lại cho chắc.

Scope: Vẫn là nó, không thay đổi gì.

Engine: Kool. Truyền giá trị của a, là 2, vào log (..).
```

### 7. Understand the rule for traversing nested Scope ?

- EM hiểu là một biến khi được sử dụng tại một phạm vi, trước tiên Engine sẽ tìm kiếm biến đó tại chính phạm vi đó, nếu không có nó sẽ trở ra phạm vi bên ngoài, cho đến khi ra ngoài phạm vi global (Tìm được thì mới dừng lại)

### 8. Understand what is lex-time ?

- Bước đầu tiên của 1 trình biên dịch (với ngôn ngữ biên dịch truyền thống) là phân tích đoạn code thành những phần nhỏ (mỗi phần gọi là token), thuật ngữ chuyên môn gọi bước này là "lexing" (hay là "tokenizing"). Quá trình "lexing" sẽ khảo sát đoạn code, thêm ý nghĩa (về mặt lập trình) cho từng token (đây là kết quả của "stateful parsing"). Khái niệm này là nền tảng để hiểu "lexical scope" là gì, và thuật ngữ này đến từ đâu.
- Việc định nghĩa "lexical scope" khá là ngoằn ngoèo, nó là ... "scope" nhưng tồn tại trong thời gian "lexing". Để đơn giản thì lexical scope được xác định vào lúc tác giả viết code, sắp xếp các variables hoặc khối code ở các vị trí nhất định. Lexical scope sẽ được giữ nguyên cho đến thời điểm "lexing" (tức là giai đoạn mà code được chia thành các phần nhỏ có ý nghĩa).

### 9. Try to cheat lexical scope with eval and with ?

```js
function foo(str, a) {
  eval(str); // đang "chơi ăn gian"!
  console.log(a, b);
}

var b = 2;

foo("var b = 3;", 1); // 1 3
```

- Tại thời điểm gọi hàm eval(..) thì chuỗi "var b = 3;" được coi như là 1 đoạn code vốn đã ở đó từ trước. Bởi trong đoạn code này có phần khai báo variable b nên lexical scope của foo(..) bị thay đổi, variable b được tạo bên trong foo(..), che đi variable b vốn được khai báo ở scope vòng tiếp theo (trường hợp này là global scope).
- Khi hàm console.log(..) được gọi, hàm này tìm thấy cả a lẫn b bên trong scope của foo(..), nó dừng ở đó mà không hề mở rộng tìm kiếm b ở scope vòng tiếp theo. Do đó, kết quả thu được là "1 3" thay vì "1 2".

### 10. "What is the output of following code:

```js
var d = 10;
function foo(a) {
  var b = a * 2;
  function bar(c) {
    console.log(a, b, c, d);
  }
  bar(b * 3);
}
foo(2);
```

Output: 2 4 12 10

### 11. Understand function scope and its implications?

- Scope là phạm vi của một biến được khai báo mà ta có thể truy cập được. Trước khi ES6 được ra mắt, JavaScript chỉ có 2 loại scope là: Global scope và Function scope. Sau khi ES6 ra mắt thì JavaScript có thêm Block scope nữa

### 12. Understand how to hide data (variables, function) using function scope ?

- Mọi biến được khai báo trong hàm thì nó đều có phạm vi hàm, bên ngoài phạm vi hàm không thể truy cập

### 13. Understand benefit of hiding variables and function inside a scope ?

- Bao đóng dữ liệu => Dữ liệu an toàn hơn, không bị trừng lặp tên biến, không thể bị sửa dữ liệu tại browser

### 14. What is global namespaces ?

- Khi khai báo một biến có phạm vi global thì nó sẽ chuyển đến một nơi được gọi là global namespaces. global namespaces cho phép các biến có thể truy cập được từ bất kì phạm vi nào trong chương trình. Các biến này sẽ vẫn ở đó cho đến khi chương trình này kết thúc

### 15. Understand 2 problems when you want to hide data ?

- Khi ẩn dữ liệu thì ta không thể thao tác trực tiếp với dữ liệu theo cách thông thường
- Lập trình viên phải viết code dài hơn, phức tạp hơn

### 16. Understand Invoking Function Expressions Immediately ?

- Gọi hàm ngay lập tức (Immediately Invoked Function Expression) là việc khai báo một hàm và thực thi nó ngay lập tức

```js
(function () {
  //code here
})();
```

### 17. Understand what is block scope ?

- Block scope là phạm vi khối, các biến chỉ có thể truy cập được ở phạm vi khối như {}, if, else, while, for, ...
- VD: Khai báo biến bằng từ khóa const, let

### 18. Understand let and const keyword ?

- let và const đều có phạm vi khối (block scope), đều được sử dụng để khai báo một biến. Chúng đều được hoisting, tuy nhiên khi hoisting nó không được gán một giá trị mặc định ban đầu
- tuy nhiên đối với biến được khai báo bằng let thì nó có thể được gán lại giá trị, còn đối với cosnt thì không bởi vì từ khóa const là khai báo biến là hằng số (immutable)

=> Việc sử dụng biến được khai báo bằng từ khóa let, const dẫn tới một lỗi như "Cần khởi tạo giá trị trước khi sử dụng biến"

### 19. Understand what happened when you try to use a variable before its declaration ?

- let và const đều được hoisting, tuy nhiên khi hoisting nó không được gán một giá trị mặc định ban đầu

=> Việc sử dụng biến được khai báo bằng từ khóa let, const dẫn tới một lỗi như "Cần khởi tạo giá trị trước khi sử dụng biến"

- Đối với biến được khai báo bằng từ khóa var thì khi sử dụng biến trước khi khai báo nó sẽ có giá trị là undefined do tính chất hoisting mặc định của Javascript

### 20. Understand what happened when you try to use a function before its declaration ?

- Function lại chia ra làm 2 loại
  - Function declare (được hoising) => Có thể sử dụng hàm trước khi khai báo
  - Function expression (không được hoisting) => Không thể sử dụng hàm trước khi khai báo

### 21. Understand what the compiler does when hoisting?

- Nó sẽ chỉ đưa khai báo lên đầu phạm vi trước khi thực thi, còn việc gán giá trị mặc định sẽ phụ thuộc vào cách thức khai báo

### 22. Understand the rules for hoisting ?

- EM đã trình bày ở những câu trên

### 23. "What is the output of following code:

```js
foo();
function foo() {
  console.log(a);
}
var a = 20;
```

=> Đầu ra sẽ là undefined

- Giải thích: Do hàm foo thuộc dạng function declaretion nên nó được hoisting, khi gọi hàm foo() nó sẽ thực thi, bên trong nó in ra biến a, tuy nhiên trong phạm vi hàn không hề có biến a này, nên nó sẽ ra phạm vi bên ngoài, lúc này do biến a được hoisting nên nó sẽ có giá trị khởi tạo là undefined

### 24. What is the definition of Closure Scope mentioned in the book ?

- Việc một hàm nhớ nơi nó được sinh ra và có thể truy cập được tham số, biến của hàm cha

### 25. What is the problem with loop and closure ?

```js
const exampleFunctions = [];
for (var i = 0; i < 3; i++) {
  exampleFunctions.push(() => {
    console.log(i);
  });
}
for (var j = 0; j < 3; j++) {
  exampleFunctions[j](); // 3, 3, 3
}
```

### 26. What is the output of following code ?

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

=> Sau khoảng thời gian quy định nó sẽ in ra số 6

### 27. "What is the output of following code?

```js
var fn;
function foo() {
  var a = 2;
  function baz() {
    console.log(a);
  }
  fn = baz;
}
function bar() {
  fn();
}
foo(); // 2
bar(); // 2
```

### 28. Dạng câu hỏi: "What is the output?"

```js
function empty(o) {
  o = null;
}
var x = [];
empty(x);
console.log(x); // [] Bởi vì sau khi gọi hàm empty(x) giá trị của x chỉ được thay đổi bên trong phạm vi của hàm
```

```js
function swap(a, b) {
  [a, b] = [b, a];
}
var x = 1;
var y = 2;
swap(x, y);
console.log(x); // 1 (giá trị của x chỉ được thay đổi bên trong phạm vi của hàm)
```

### 29. Write a function addf that adds from 2 invocations.

Example: addf(3)(4); // 7

- CODE

```js
function addf(x) {
  return function (y) {
    console.log(x + y);
  };
}
addf(5)(7);
```

### 30. Write a function liftf that takes a binary function, and makes it callable with 2 invocations. Example:

```js
var addf = liftf(add);
addf(3)(4); // 7
liftf(mul)(5)(6); // 30
```

- CODE

```js
function liftf(expressMath) {
  return function (x) {
    return function (y) {
      if (expressMath === "add") {
        console.log(x + y);
      }
      if (expressMath == "mul") {
        console.log(x * y);
      }
    };
  };
}

liftf("add")(4)(3); // 7
liftf("mul")(4)(3); // 12
```

### 31. Write a function curry that takes a binary function and an argument, and returns a function that can take a second arguments. Example:

```js
var add3 = curry(add, 3);
add3(4); // 7
curry(mul, 5)(6); // 30
```

- CODE

```js
function curry(expressMath, x) {
  return function (y) {
    if (expressMath === "add") {
      console.log(x + y);
    }
    if (expressMath === "mul") {
      console.log(x * y);
    }
  };
}

var add3 = curry("add", 3);
add3(4); // 7
curry("mul", 5)(6); // 30
```

### 32. Write a fromTo function that return a generator that produce values in a range. Example:

```js
var index = fromTo(0, 3);
index(); // 0
index(); // 1
index(); // 2
index(); // undefined
```

- CODE

```js
function fromTo(from, to) {
  let count = from;
  return function () {
    console.log(count);
    if (count < to - 1) {
      count++;
    } else {
      count = undefined;
    }
  };
}
var index = fromTo(0, 3);
index(); // 0
index(); // 1
index(); // 2
index(); // undefined
index(); // undefined
index(); // undefined
```
